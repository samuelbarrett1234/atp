<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>atp: atp::logic::equational Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">atp
   &#160;<span id="projectnumber">Pre-alpha</span>
   </div>
   <div id="projectbrief">An automated theorem prover in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceatp.html">atp</a></li><li class="navelem"><a class="el" href="namespaceatp_1_1logic.html">logic</a></li><li class="navelem"><a class="el" href="namespaceatp_1_1logic_1_1equational.html">equational</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atp::logic::equational Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for the equational logic implementation.  
<a href="namespaceatp_1_1logic_1_1equational.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceatp_1_1logic_1_1equational_1_1semantics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational_1_1semantics.html">semantics</a></td></tr>
<tr class="memdesc:namespaceatp_1_1logic_1_1equational_1_1semantics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all the functions relating to the semantics (logical inference etc) of equational logic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_constant_syntax_node.html">ConstantSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatp_1_1logic_1_1equational_1_1_definition_grammar.html">DefinitionGrammar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grammar for definition files (producing name-arity pairs.)  <a href="structatp_1_1logic_1_1equational_1_1_definition_grammar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html">EqParseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the '=' sign at the top of a statement, which has a LHS and a RHS.  <a href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html">EqSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_free_syntax_node.html">FreeSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html">FuncSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html">IdentifierParseNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html">IParseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base parse node interface.  <a href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html">KnowledgeKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_language.html">Language</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatp_1_1logic_1_1equational_1_1_skipper.html">Skipper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the skip parser, which tells the parser what to ignore (what is not code).  <a href="structatp_1_1logic_1_1equational_1_1_skipper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_statement.html">Statement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_statement_array.html">StatementArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatp_1_1logic_1_1equational_1_1_statement_grammar.html">StatementGrammar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grammar for statement objects (producing parse trees)  <a href="structatp_1_1logic_1_1equational_1_1_statement_grammar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae54101c14d30ddb9798a1f747adee92b"><td class="memItemLeft" align="right" valign="top">typedef boost::spirit::istream_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">QiParseIterator</a></td></tr>
<tr class="separator:ae54101c14d30ddb9798a1f747adee92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c176681e5964c28c42d71bfdb754ae"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html">IParseNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a></td></tr>
<tr class="separator:aa4c176681e5964c28c42d71bfdb754ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512c70cd56e63c05c448e31bbb98d6d9"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a></td></tr>
<tr class="separator:a512c70cd56e63c05c448e31bbb98d6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a379b0decdece9de86db218c905d4f930"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930">ParseNodeType</a> { <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930a2dcbad7477fd40561e8b8198f173bd47">ParseNodeType::EQ</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930a6fcc416051346daca31c571646af127a">ParseNodeType::IDENTIFIER</a>
 }</td></tr>
<tr class="separator:a379b0decdece9de86db218c905d4f930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04726a5939dff190edd4935738778459"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459">SyntaxNodeType</a> { <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a2dcbad7477fd40561e8b8198f173bd47">SyntaxNodeType::EQ</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a88c189a42c87aa49d667fc8ab76bc323">SyntaxNodeType::FREE</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a8d6b5cada83510220f59e00ce86d4d92">SyntaxNodeType::CONSTANT</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a1e49c8ad07b69571bfcafaf18ac9fa5b">SyntaxNodeType::FUNC</a>
 }</td></tr>
<tr class="separator:a04726a5939dff190edd4935738778459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a937ec99a9c46acc458fc08b706187350"><td class="memItemLeft" align="right" valign="top">qi::rule&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">QiParseIterator</a>, std::string(), <a class="el" href="structatp_1_1logic_1_1equational_1_1_skipper.html">Skipper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a937ec99a9c46acc458fc08b706187350">Identifier</a> ()</td></tr>
<tr class="memdesc:a937ec99a9c46acc458fc08b706187350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse rule for identifiers.  <a href="namespaceatp_1_1logic_1_1equational.html#a937ec99a9c46acc458fc08b706187350">More...</a><br /></td></tr>
<tr class="separator:a937ec99a9c46acc458fc08b706187350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328cf188236eb9da94082159cb4ab37b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::list&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a328cf188236eb9da94082159cb4ab37b">parse_statements</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a328cf188236eb9da94082159cb4ab37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a stream of line separated statements, and return the list of their parse trees, or None if an error occurred with any of them.  <a href="namespaceatp_1_1logic_1_1equational.html#a328cf188236eb9da94082159cb4ab37b">More...</a><br /></td></tr>
<tr class="separator:a328cf188236eb9da94082159cb4ab37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ac987bc45033e4e25c7419d62f7107"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::list&lt; std::pair&lt; std::string, size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a35ac987bc45033e4e25c7419d62f7107">parse_definitions</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a35ac987bc45033e4e25c7419d62f7107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a stream of line separated definitions, where a definition is a (string, int) pair, representing the symbol name and the symbol arity, respectively.  <a href="namespaceatp_1_1logic_1_1equational.html#a35ac987bc45033e4e25c7419d62f7107">More...</a><br /></td></tr>
<tr class="separator:a35ac987bc45033e4e25c7419d62f7107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f7bc7ced86a79f9e8f436630704152"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqFuncT , typename IdentifierFuncT &gt; </td></tr>
<tr class="memitem:ac5f7bc7ced86a79f9e8f436630704152"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#ac5f7bc7ced86a79f9e8f436630704152">fold_parse_tree</a> (EqFuncT eq_func, IdentifierFuncT identifier_func, <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> p_root)</td></tr>
<tr class="memdesc:ac5f7bc7ced86a79f9e8f436630704152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold operation over a given parse tree.  <a href="namespaceatp_1_1logic_1_1equational.html#ac5f7bc7ced86a79f9e8f436630704152">More...</a><br /></td></tr>
<tr class="separator:ac5f7bc7ced86a79f9e8f436630704152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600e551abcaab4c45b8e88e7ea3c219d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a600e551abcaab4c45b8e88e7ea3c219d">compute_slice_size</a> (size_t start, size_t end, size_t step)</td></tr>
<tr class="memdesc:a600e551abcaab4c45b8e88e7ea3c219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for computing the number of elements in slices.  <a href="namespaceatp_1_1logic_1_1equational.html#a600e551abcaab4c45b8e88e7ea3c219d">More...</a><br /></td></tr>
<tr class="separator:a600e551abcaab4c45b8e88e7ea3c219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e9394c32234654be6b72f903c6982d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae1e9394c32234654be6b72f903c6982d">ptree_to_stree</a> (<a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> ptree, const <a class="el" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html">KnowledgeKernel</a> &amp;ker)</td></tr>
<tr class="memdesc:ae1e9394c32234654be6b72f903c6982d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a parse tree into a syntax tree.  <a href="namespaceatp_1_1logic_1_1equational.html#ae1e9394c32234654be6b72f903c6982d">More...</a><br /></td></tr>
<tr class="separator:ae1e9394c32234654be6b72f903c6982d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56781fb4943ed73eaf36ccac9d19d54f"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </td></tr>
<tr class="memitem:a56781fb4943ed73eaf36ccac9d19d54f"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a56781fb4943ed73eaf36ccac9d19d54f">fold_syntax_tree</a> (EqFuncT eq_func, FreeFuncT free_func, ConstFuncT const_func, FFuncT f_func, <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> p_root)</td></tr>
<tr class="memdesc:a56781fb4943ed73eaf36ccac9d19d54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold operation over a given syntax tree.  <a href="namespaceatp_1_1logic_1_1equational.html#a56781fb4943ed73eaf36ccac9d19d54f">More...</a><br /></td></tr>
<tr class="separator:a56781fb4943ed73eaf36ccac9d19d54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc1e51442b357251db8433f182cf0d"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </td></tr>
<tr class="memitem:a9ddc1e51442b357251db8433f182cf0d"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a9ddc1e51442b357251db8433f182cf0d">apply_to_syntax_node</a> (EqFuncT eq_func, FreeFuncT free_func, ConstFuncT const_func, FFuncT f_func, <a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a> &amp;node)</td></tr>
<tr class="memdesc:a9ddc1e51442b357251db8433f182cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a different function depending on the node type.  <a href="namespaceatp_1_1logic_1_1equational.html#a9ddc1e51442b357251db8433f182cf0d">More...</a><br /></td></tr>
<tr class="separator:a9ddc1e51442b357251db8433f182cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for the equational logic implementation. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa4c176681e5964c28c42d71bfdb754ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c176681e5964c28c42d71bfdb754ae">&#9670;&nbsp;</a></span>ParseNodePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html">IParseNode</a>&gt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">atp::logic::equational::ParseNodePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae54101c14d30ddb9798a1f747adee92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54101c14d30ddb9798a1f747adee92b">&#9670;&nbsp;</a></span>QiParseIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::spirit::istream_iterator <a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">atp::logic::equational::QiParseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a512c70cd56e63c05c448e31bbb98d6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512c70cd56e63c05c448e31bbb98d6d9">&#9670;&nbsp;</a></span>SyntaxNodePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a>&gt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">atp::logic::equational::SyntaxNodePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a379b0decdece9de86db218c905d4f930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379b0decdece9de86db218c905d4f930">&#9670;&nbsp;</a></span>ParseNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930">atp::logic::equational::ParseNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a379b0decdece9de86db218c905d4f930a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a379b0decdece9de86db218c905d4f930a6fcc416051346daca31c571646af127a"></a>IDENTIFIER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a04726a5939dff190edd4935738778459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04726a5939dff190edd4935738778459">&#9670;&nbsp;</a></span>SyntaxNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459">atp::logic::equational::SyntaxNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a88c189a42c87aa49d667fc8ab76bc323"></a>FREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a8d6b5cada83510220f59e00ce86d4d92"></a>CONSTANT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a1e49c8ad07b69571bfcafaf18ac9fa5b"></a>FUNC&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9ddc1e51442b357251db8433f182cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddc1e51442b357251db8433f182cf0d">&#9670;&nbsp;</a></span>apply_to_syntax_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::apply_to_syntax_node </td>
          <td>(</td>
          <td class="paramtype">EqFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFuncT&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstFuncT&#160;</td>
          <td class="paramname"><em>const_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFuncT&#160;</td>
          <td class="paramname"><em>f_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a different function depending on the node type. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a <code>map</code> operation from functional programming</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>the return result type</td></tr>
    <tr><td class="paramname">EqFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html">EqSyntaxNode</a>&amp; -&gt; ResultT</td></tr>
    <tr><td class="paramname">FreeFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_free_syntax_node.html">FreeSyntaxNode</a>&amp; -&gt; ResultT</td></tr>
    <tr><td class="paramname">ConstFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_constant_syntax_node.html">ConstantSyntaxNode</a>&amp; -&gt; ResultT</td></tr>
    <tr><td class="paramname">FFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html">FuncSyntaxNode</a>&amp; -&gt; ResultT </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph" id="namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph">
<area shape="rect" title="Apply a different function depending on the node type." alt="" coords="5,5,165,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html#abeec346aa5f82fc170e2bb2765c04a5a" title=" " alt="" coords="213,5,376,47"/>
</map>
</div>

</div>
</div>
<a id="a600e551abcaab4c45b8e88e7ea3c219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600e551abcaab4c45b8e88e7ea3c219d">&#9670;&nbsp;</a></span>compute_slice_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> size_t atp::logic::equational::compute_slice_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for computing the number of elements in slices. </p>
<dl class="section pre"><dt>Precondition</dt><dd>start &lt;= end and step &gt; 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>returns the number of integers k &gt;= 0 such that start + k * step &lt; end. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph" id="namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph">
<area shape="rect" title="Helper function for computing the number of elements in slices." alt="" coords="713,35,859,76"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_statement_array.html#ada8f04815314efc4e444cce3d22db612" title=" " alt="" coords="512,64,665,105"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_statement_array.html#a88936889bc98a77d1f0ccc070e5728e6" title=" " alt="" coords="276,5,432,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_statement_array.html#a427d3b1b8f56c9593fffc55ef3ce11e0" title=" " alt="" coords="244,71,464,112"/>
<area shape="rect" href="_statement_array_tests_8cpp.html#a078359bc65a5267d920fc6d1f541ad27" title=" " alt="" coords="5,13,196,39"/>
</map>
</div>

</div>
</div>
<a id="ac5f7bc7ced86a79f9e8f436630704152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f7bc7ced86a79f9e8f436630704152">&#9670;&nbsp;</a></span>fold_parse_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqFuncT , typename IdentifierFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::fold_parse_tree </td>
          <td>(</td>
          <td class="paramtype">EqFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IdentifierFuncT&#160;</td>
          <td class="paramname"><em>identifier_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a>&#160;</td>
          <td class="paramname"><em>p_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fold operation over a given parse tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>The return type of this operation.</td></tr>
    <tr><td class="paramname">EqFuncT</td><td>The function to use as the equality node constructor, which must have type ResultT x ResultT -&gt; ResultT</td></tr>
    <tr><td class="paramname">IdentifierFuncT</td><td>The function to use as the identifier node constructor, which must have type std::string x std::list&lt;ResultT&gt;::iterator x std::list&lt;ResultT&gt;::iterator -&gt; ResultT</td></tr>
  </table>
  </dd>
</dl>
<p>Folds are a special kind of concept, prominent in functional programming. Applying a fold to a tree like this one can be a useful way of computing/aggregating information over the tree without having to write boilerplate code. A fold basically works by specifying a function to apply for each kind of node, and the fold then handles the rest of the recursion for you. However, recursion is inefficient, so we use a stack instead. In particular, we use two stacks: one for keeping track of which nodes we are yet to examine, and which results we are yet to use. Some nodes need to be examined twice (the first time, we push its children onto the stack. the second time, we combine the results of its children and push our result to the results_stack) thus we have a set of seen nodes too. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph" id="namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph">
<area shape="rect" title="Perform a fold operation over a given parse tree." alt="" coords="5,266,148,307"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a6618f693f5e35cb6a1858b21e1a9b1a2" title=" " alt="" coords="212,5,355,61"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a3818c3237a7a55c740540293031e4678" title=" " alt="" coords="198,86,369,127"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a551c25e7739c0344a9fc78d76e8616df" title=" " alt="" coords="212,152,355,208"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html#ad1c5644349c91762784561e984c333bc" title=" " alt="" coords="206,233,361,274"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html#a315b06b092eff96a2f708ab8bfea4dd8" title=" " alt="" coords="212,298,355,339"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a4addc3dc6f1148c3da4d04a89b028dff" title=" " alt="" coords="212,364,355,420"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a7516bc05c496bf3aa2de7928826ae23c" title=" " alt="" coords="196,445,371,486"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html#a79b29db5e3721a74755ac89e53f97a5b" title=" " alt="" coords="212,510,355,551"/>
</map>
</div>

</div>
</div>
<a id="a56781fb4943ed73eaf36ccac9d19d54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56781fb4943ed73eaf36ccac9d19d54f">&#9670;&nbsp;</a></span>fold_syntax_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::fold_syntax_tree </td>
          <td>(</td>
          <td class="paramtype">EqFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFuncT&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstFuncT&#160;</td>
          <td class="paramname"><em>const_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFuncT&#160;</td>
          <td class="paramname"><em>f_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a>&#160;</td>
          <td class="paramname"><em>p_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fold operation over a given syntax tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>The return type of this operation.</td></tr>
    <tr><td class="paramname">EqFuncT</td><td>The function to use as the equality node constructor, which must have type ResultT x ResultT -&gt; ResultT</td></tr>
    <tr><td class="paramname">FreeFuncT</td><td>The function to use as the free variable node constructor, with type size_t -&gt; ResultT</td></tr>
    <tr><td class="paramname">ConstFuncT</td><td>The function to use as the constant node constructor, with type size_t -&gt; ResultT</td></tr>
    <tr><td class="paramname">FFuncT</td><td>The function to use as the function node constructor, with type size_t x std::list&lt;ResultT&gt;::iterator x std::list&lt;ResultT&gt;::iterator -&gt; ResultT</td></tr>
  </table>
  </dd>
</dl>
<p>Folds are a special kind of concept, prominent in functional programming. Applying a fold to a tree like this one can be a useful way of computing/aggregating information over the tree without having to write boilerplate code. A fold basically works by specifying a function to apply for each kind of node, and the fold then handles the rest of the recursion for you. However, recursion is inefficient, so we use a stack instead. In particular, we use two stacks: one for keeping track of which nodes we are yet to examine, and which results we are yet to use. Some nodes need to be examined twice (the first time, we push its children onto the stack. the second time, we combine the results of its children and push our result to the results_stack) thus we have a set of seen nodes too. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a56781fb4943ed73eaf36ccac9d19d54f_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a56781fb4943ed73eaf36ccac9d19d54f_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a56781fb4943ed73eaf36ccac9d19d54f_cgraph" id="namespaceatp_1_1logic_1_1equational_a56781fb4943ed73eaf36ccac9d19d54f_cgraph">
<area shape="rect" title="Perform a fold operation over a given syntax tree." alt="" coords="5,39,148,80"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html#ab387f330c6f631916a017bf368a24845" title=" " alt="" coords="200,5,343,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html#a725fafce5637f9a5b1862f9e04baddea" title=" " alt="" coords="196,71,347,112"/>
</map>
</div>

</div>
</div>
<a id="a937ec99a9c46acc458fc08b706187350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937ec99a9c46acc458fc08b706187350">&#9670;&nbsp;</a></span>Identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::spirit::qi::rule&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">QiParseIterator</a>, std::string(), <a class="el" href="structatp_1_1logic_1_1equational_1_1_skipper.html">Skipper</a> &gt; atp::logic::equational::Identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse rule for identifiers. </p>
<p>An identifier is a kind of name, for a free variable, constant or function. Includes alphanumeric and some symbols. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph" id="namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph">
<area shape="rect" title="Parse rule for identifiers." alt="" coords="265,53,408,94"/>
<area shape="rect" href="structatp_1_1logic_1_1equational_1_1_definition_grammar.html#ace8b0bd28c3ec798adbbc8b7eca40ed4" title=" " alt="" coords="12,5,211,61"/>
<area shape="rect" href="structatp_1_1logic_1_1equational_1_1_statement_grammar.html#accc11d7d49fd2976f194ad146bfba551" title=" " alt="" coords="5,85,217,141"/>
</map>
</div>

</div>
</div>
<a id="a35ac987bc45033e4e25c7419d62f7107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ac987bc45033e4e25c7419d62f7107">&#9670;&nbsp;</a></span>parse_definitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> boost::optional&lt; std::list&lt; std::pair&lt; std::string, size_t &gt; &gt; &gt; atp::logic::equational::parse_definitions </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a stream of line separated definitions, where a definition is a (string, int) pair, representing the symbol name and the symbol arity, respectively. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of (symbol name, symbol arity) pairs if the parse was successful, or None if there was a parser error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Comments are done using the hashtag # </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a35ac987bc45033e4e25c7419d62f7107_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a35ac987bc45033e4e25c7419d62f7107_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a35ac987bc45033e4e25c7419d62f7107_icgraph" id="namespaceatp_1_1logic_1_1equational_a35ac987bc45033e4e25c7419d62f7107_icgraph">
<area shape="rect" title="Read a stream of line separated definitions, where a definition is a (string, int) pair,..." alt="" coords="244,27,387,69"/>
<area shape="rect" href="_parse_definitions_tests_8cpp.html#aba48693f13a58a46c98f513043484e86" title=" " alt="" coords="5,5,196,32"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#ae71040498b42b9764a6523734d748613" title="Load the knowledge kernel from a given stream (of e.g. definitions.)" alt="" coords="21,57,181,98"/>
</map>
</div>

</div>
</div>
<a id="a328cf188236eb9da94082159cb4ab37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328cf188236eb9da94082159cb4ab37b">&#9670;&nbsp;</a></span>parse_statements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> boost::optional&lt; std::list&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> &gt; &gt; atp::logic::equational::parse_statements </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a stream of line separated statements, and return the list of their parse trees, or None if an error occurred with any of them. </p>
<dl class="section note"><dt>Note</dt><dd>Comments are done using the hashtag # </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph" id="namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph">
<area shape="rect" title="Read a stream of line separated statements, and return the list of their parse trees,..." alt="" coords="505,78,648,119"/>
<area shape="rect" href="_parse_statements_tests_8cpp.html#aa853ae4d9a1ae76af3b903e691dc5918" title=" " alt="" coords="261,5,452,32"/>
<area shape="rect" href="_semantics_helper_tests_8cpp.html#ad59a5db95d75209c7d2b8c6efe611f09" title=" " alt="" coords="261,56,452,83"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#ae7d262bb891a260e02cf9236ae494f26" title="Load an array of statements from an input stream, in the context of a given kernel." alt="" coords="259,107,455,149"/>
<area shape="rect" href="struct_semantics_helper_tests_fixture.html#a5748077825546fdbb31d0ecf060df206" title=" " alt="" coords="256,173,457,214"/>
<area shape="rect" href="struct_knowledge_kernel_inference_tests_fixture.html#ad46a85e1930b051fdff80bc0769cb404" title=" " alt="" coords="5,100,208,156"/>
</map>
</div>

</div>
</div>
<a id="ae1e9394c32234654be6b72f903c6982d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e9394c32234654be6b72f903c6982d">&#9670;&nbsp;</a></span>ptree_to_stree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> atp::logic::equational::ptree_to_stree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a>&#160;</td>
          <td class="paramname"><em>ptree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html">KnowledgeKernel</a> &amp;&#160;</td>
          <td class="paramname"><em>ker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a parse tree into a syntax tree. </p>
<dl class="section note"><dt>Note</dt><dd>This performs type checking, which is why we require the kernel</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if failed, otherwise returns the root to the syntax tree. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_cgraph" id="namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_cgraph">
<area shape="rect" title="Convert a parse tree into a syntax tree." alt="" coords="5,93,148,134"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#af7ae5937b36a9fd2a8427b543b47ed56" title=" " alt="" coords="221,5,369,61"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#ac6817a1e4df3b10bd9bed1126aa35304" title=" " alt="" coords="205,85,385,141"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#ac6039360852cfb5619615af8bf2d2072" title=" " alt="" coords="196,166,393,207"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_icgraph" id="namespaceatp_1_1logic_1_1equational_ae1e9394c32234654be6b72f903c6982d_icgraph">
<area shape="rect" title="Convert a parse tree into a syntax tree." alt="" coords="505,78,648,119"/>
<area shape="rect" href="_semantics_tests_8cpp.html#af5299414cd1e034d625bd038fd49dacc" title=" " alt="" coords="261,5,452,32"/>
<area shape="rect" href="_semantics_helper_tests_8cpp.html#ad59a5db95d75209c7d2b8c6efe611f09" title=" " alt="" coords="261,56,452,83"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#ae7d262bb891a260e02cf9236ae494f26" title="Load an array of statements from an input stream, in the context of a given kernel." alt="" coords="259,107,455,149"/>
<area shape="rect" href="struct_semantics_helper_tests_fixture.html#a5748077825546fdbb31d0ecf060df206" title=" " alt="" coords="256,173,457,214"/>
<area shape="rect" href="struct_knowledge_kernel_inference_tests_fixture.html#ad46a85e1930b051fdff80bc0769cb404" title=" " alt="" coords="5,100,208,156"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
