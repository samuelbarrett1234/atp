<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>atp: atp::logic::equational Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">atp
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">An automated theorem prover in C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceatp.html">atp</a></li><li class="navelem"><a class="el" href="namespaceatp_1_1logic.html">logic</a></li><li class="navelem"><a class="el" href="namespaceatp_1_1logic_1_1equational.html">equational</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atp::logic::equational Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for the equational logic implementation.  
<a href="namespaceatp_1_1logic_1_1equational.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_constant_syntax_node.html">ConstantSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html">EqParseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the '=' sign at the top of a statement, which has a LHS and a RHS.  <a href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html">EqSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression is an encapsulation of the part of a syntax tree without an equals sign.  <a href="classatp_1_1logic_1_1equational_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_expr_tree_flyweight.html">ExprTreeFlyweight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class encapsulates the complexity of storing an expression's syntax tree efficiently.  <a href="classatp_1_1logic_1_1equational_1_1_expr_tree_flyweight.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_free_syntax_node.html">FreeSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_free_var_assignment_iterator.html">FreeVarAssignmentIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces statement successors by iterating over possible assignments of free variables not covered by an existing mapping.  <a href="classatp_1_1logic_1_1equational_1_1_free_var_assignment_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html">FuncSyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html">IdentifierParseNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html">IParseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base parse node interface.  <a href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html">KnowledgeKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classatp_1_1logic_1_1_i_knowledge_kernel.html" title="Represents a collection of definitions and axioms, associated with a particular ILanguage,...">IKnowledgeKernel</a> implementation for equational logic.  <a href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_language.html">Language</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_match_results_iterator.html">MatchResultsIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces statement successors by iterating over the results of a successful matching.  <a href="classatp_1_1logic_1_1equational_1_1_match_results_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_model_context.html">ModelContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic implementation of the model context, for equational logic.  <a href="classatp_1_1logic_1_1equational_1_1_model_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_no_repeat_iterator.html">NoRepeatIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classatp_1_1logic_1_1equational_1_1_no_repeat_iterator.html" title="The NoRepeatIterator blocks states that have already been seen on the path from the root to the curre...">NoRepeatIterator</a> blocks states that have already been seen on the path from the root to the current node. It does so by wrapping around another given iterator.  <a href="classatp_1_1logic_1_1equational_1_1_no_repeat_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_proof_state.html">ProofState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proof states for equational logic.  <a href="classatp_1_1logic_1_1equational_1_1_proof_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_rule_matching_iterator.html">RuleMatchingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces successor statements by iterating over possible matchings.  <a href="classatp_1_1logic_1_1equational_1_1_rule_matching_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatp_1_1logic_1_1equational_1_1_skipper.html">Skipper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the skip parser, which tells the parser what to ignore (what is not code).  <a href="structatp_1_1logic_1_1equational_1_1_skipper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_statement.html">Statement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_statement_array.html">StatementArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structatp_1_1logic_1_1equational_1_1_statement_grammar.html">StatementGrammar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grammar for statement objects (producing parse trees)  <a href="structatp_1_1logic_1_1equational_1_1_statement_grammar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatp_1_1logic_1_1equational_1_1_sub_expr_matching_iterator.html">SubExprMatchingIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces successor statements by iterating over all subtrees of a statement to try matching.  <a href="classatp_1_1logic_1_1equational_1_1_sub_expr_matching_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8381a48c4405f442446286da942e8139"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classatp_1_1logic_1_1equational_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a8381a48c4405f442446286da942e8139">ExpressionPtr</a></td></tr>
<tr class="separator:a8381a48c4405f442446286da942e8139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54101c14d30ddb9798a1f747adee92b"><td class="memItemLeft" align="right" valign="top">typedef boost::spirit::istream_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">QiParseIterator</a></td></tr>
<tr class="separator:ae54101c14d30ddb9798a1f747adee92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c176681e5964c28c42d71bfdb754ae"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html">IParseNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a></td></tr>
<tr class="separator:aa4c176681e5964c28c42d71bfdb754ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512c70cd56e63c05c448e31bbb98d6d9"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a></td></tr>
<tr class="separator:a512c70cd56e63c05c448e31bbb98d6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a379b0decdece9de86db218c905d4f930"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930">ParseNodeType</a> { <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930a2dcbad7477fd40561e8b8198f173bd47">ParseNodeType::EQ</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930a6fcc416051346daca31c571646af127a">ParseNodeType::IDENTIFIER</a>
 }</td></tr>
<tr class="separator:a379b0decdece9de86db218c905d4f930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04726a5939dff190edd4935738778459"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459">SyntaxNodeType</a> { <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a2dcbad7477fd40561e8b8198f173bd47">SyntaxNodeType::EQ</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a88c189a42c87aa49d667fc8ab76bc323">SyntaxNodeType::FREE</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a8d6b5cada83510220f59e00ce86d4d92">SyntaxNodeType::CONSTANT</a>, 
<a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459a1e49c8ad07b69571bfcafaf18ac9fa5b">SyntaxNodeType::FUNC</a>
 }</td></tr>
<tr class="separator:a04726a5939dff190edd4935738778459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a937ec99a9c46acc458fc08b706187350"><td class="memItemLeft" align="right" valign="top">qi::rule&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">QiParseIterator</a>, std::string(), <a class="el" href="structatp_1_1logic_1_1equational_1_1_skipper.html">Skipper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a937ec99a9c46acc458fc08b706187350">Identifier</a> ()</td></tr>
<tr class="memdesc:a937ec99a9c46acc458fc08b706187350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse rule for identifiers.  <a href="namespaceatp_1_1logic_1_1equational.html#a937ec99a9c46acc458fc08b706187350">More...</a><br /></td></tr>
<tr class="separator:a937ec99a9c46acc458fc08b706187350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328cf188236eb9da94082159cb4ab37b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::list&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a328cf188236eb9da94082159cb4ab37b">parse_statements</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a328cf188236eb9da94082159cb4ab37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a stream of line separated statements, and return the list of their parse trees, or None if an error occurred with any of them.  <a href="namespaceatp_1_1logic_1_1equational.html#a328cf188236eb9da94082159cb4ab37b">More...</a><br /></td></tr>
<tr class="separator:a328cf188236eb9da94082159cb4ab37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f7bc7ced86a79f9e8f436630704152"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqFuncT , typename IdentifierFuncT &gt; </td></tr>
<tr class="memitem:ac5f7bc7ced86a79f9e8f436630704152"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#ac5f7bc7ced86a79f9e8f436630704152">fold_parse_tree</a> (EqFuncT eq_func, IdentifierFuncT identifier_func, <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> p_root)</td></tr>
<tr class="memdesc:ac5f7bc7ced86a79f9e8f436630704152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold operation over a given parse tree.  <a href="namespaceatp_1_1logic_1_1equational.html#ac5f7bc7ced86a79f9e8f436630704152">More...</a><br /></td></tr>
<tr class="separator:ac5f7bc7ced86a79f9e8f436630704152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600e551abcaab4c45b8e88e7ea3c219d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a600e551abcaab4c45b8e88e7ea3c219d">compute_slice_size</a> (size_t start, size_t end, size_t step)</td></tr>
<tr class="memdesc:a600e551abcaab4c45b8e88e7ea3c219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for computing the number of elements in slices.  <a href="namespaceatp_1_1logic_1_1equational.html#a600e551abcaab4c45b8e88e7ea3c219d">More...</a><br /></td></tr>
<tr class="separator:a600e551abcaab4c45b8e88e7ea3c219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd07efe73f4ffca98e0a24d9d5d6d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a21fd07efe73f4ffca98e0a24d9d5d6d5">ptree_to_stree</a> (<a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> ptree, const <a class="el" href="classatp_1_1logic_1_1equational_1_1_model_context.html">ModelContext</a> &amp;ctx)</td></tr>
<tr class="memdesc:a21fd07efe73f4ffca98e0a24d9d5d6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a parse tree into a syntax tree.  <a href="namespaceatp_1_1logic_1_1equational.html#a21fd07efe73f4ffca98e0a24d9d5d6d5">More...</a><br /></td></tr>
<tr class="separator:a21fd07efe73f4ffca98e0a24d9d5d6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b11e0f5e91e0a6368650b5a93fa992"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </td></tr>
<tr class="memitem:a91b11e0f5e91e0a6368650b5a93fa992"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a91b11e0f5e91e0a6368650b5a93fa992">fold_syntax_tree</a> (EqFuncT eq_func, FreeFuncT free_func, ConstFuncT const_func, FFuncT f_func, const <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> &amp;p_root)</td></tr>
<tr class="memdesc:a91b11e0f5e91e0a6368650b5a93fa992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold operation over a given syntax tree.  <a href="namespaceatp_1_1logic_1_1equational.html#a91b11e0f5e91e0a6368650b5a93fa992">More...</a><br /></td></tr>
<tr class="separator:a91b11e0f5e91e0a6368650b5a93fa992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b43007ab2f1f5d4849d5b958f376fb"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqPairFuncT , typename FreePairFuncT , typename ConstPairFuncT , typename FuncPairFuncT , typename DefaultPairFuncT &gt; </td></tr>
<tr class="memitem:a28b43007ab2f1f5d4849d5b958f376fb"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a28b43007ab2f1f5d4849d5b958f376fb">fold_pair_syntax_tree</a> (EqPairFuncT eq_func, FreePairFuncT free_func, ConstPairFuncT const_func, FuncPairFuncT f_func, DefaultPairFuncT default_func, <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> a, <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> b)</td></tr>
<tr class="memdesc:a28b43007ab2f1f5d4849d5b958f376fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over pairs of syntax trees, where the fold constructor is dependent on the node types of the pair. There are functions for pairs of matching types, and then a default function for when the pairs do not match.  <a href="namespaceatp_1_1logic_1_1equational.html#a28b43007ab2f1f5d4849d5b958f376fb">More...</a><br /></td></tr>
<tr class="separator:a28b43007ab2f1f5d4849d5b958f376fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddc1e51442b357251db8433f182cf0d"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </td></tr>
<tr class="memitem:a9ddc1e51442b357251db8433f182cf0d"><td class="memTemplItemLeft" align="right" valign="top">ResultT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a9ddc1e51442b357251db8433f182cf0d">apply_to_syntax_node</a> (EqFuncT eq_func, FreeFuncT free_func, ConstFuncT const_func, FFuncT f_func, <a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a> &amp;node)</td></tr>
<tr class="memdesc:a9ddc1e51442b357251db8433f182cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a different function depending on the node type.  <a href="namespaceatp_1_1logic_1_1equational.html#a9ddc1e51442b357251db8433f182cf0d">More...</a><br /></td></tr>
<tr class="separator:a9ddc1e51442b357251db8433f182cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for the equational logic implementation. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8381a48c4405f442446286da942e8139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8381a48c4405f442446286da942e8139">&#9670;&nbsp;</a></span>ExpressionPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classatp_1_1logic_1_1equational_1_1_expression.html">Expression</a>&gt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a8381a48c4405f442446286da942e8139">atp::logic::equational::ExpressionPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4c176681e5964c28c42d71bfdb754ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c176681e5964c28c42d71bfdb754ae">&#9670;&nbsp;</a></span>ParseNodePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html">IParseNode</a>&gt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">atp::logic::equational::ParseNodePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae54101c14d30ddb9798a1f747adee92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54101c14d30ddb9798a1f747adee92b">&#9670;&nbsp;</a></span>QiParseIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::spirit::istream_iterator <a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">atp::logic::equational::QiParseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a512c70cd56e63c05c448e31bbb98d6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512c70cd56e63c05c448e31bbb98d6d9">&#9670;&nbsp;</a></span>SyntaxNodePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a>&gt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">atp::logic::equational::SyntaxNodePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a379b0decdece9de86db218c905d4f930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379b0decdece9de86db218c905d4f930">&#9670;&nbsp;</a></span>ParseNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a379b0decdece9de86db218c905d4f930">atp::logic::equational::ParseNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a379b0decdece9de86db218c905d4f930a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a379b0decdece9de86db218c905d4f930a6fcc416051346daca31c571646af127a"></a>IDENTIFIER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a04726a5939dff190edd4935738778459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04726a5939dff190edd4935738778459">&#9670;&nbsp;</a></span>SyntaxNodeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a04726a5939dff190edd4935738778459">atp::logic::equational::SyntaxNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a2dcbad7477fd40561e8b8198f173bd47"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a88c189a42c87aa49d667fc8ab76bc323"></a>FREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a8d6b5cada83510220f59e00ce86d4d92"></a>CONSTANT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04726a5939dff190edd4935738778459a1e49c8ad07b69571bfcafaf18ac9fa5b"></a>FUNC&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9ddc1e51442b357251db8433f182cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddc1e51442b357251db8433f182cf0d">&#9670;&nbsp;</a></span>apply_to_syntax_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::apply_to_syntax_node </td>
          <td>(</td>
          <td class="paramtype">EqFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFuncT&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstFuncT&#160;</td>
          <td class="paramname"><em>const_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFuncT&#160;</td>
          <td class="paramname"><em>f_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html">ISyntaxNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a different function depending on the node type. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a <code>map</code> operation from functional programming</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>the return result type</td></tr>
    <tr><td class="paramname">EqFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html">EqSyntaxNode</a>&amp; -&gt; ResultT</td></tr>
    <tr><td class="paramname">FreeFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_free_syntax_node.html">FreeSyntaxNode</a>&amp; -&gt; ResultT</td></tr>
    <tr><td class="paramname">ConstFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_constant_syntax_node.html">ConstantSyntaxNode</a>&amp; -&gt; ResultT</td></tr>
    <tr><td class="paramname">FFuncT</td><td>should be of type <a class="el" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html">FuncSyntaxNode</a>&amp; -&gt; ResultT </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph" id="namespaceatp_1_1logic_1_1equational_a9ddc1e51442b357251db8433f182cf0d_cgraph">
<area shape="rect" title="Apply a different function depending on the node type." alt="" coords="5,5,165,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_i_syntax_node.html#abeec346aa5f82fc170e2bb2765c04a5a" title=" " alt="" coords="213,5,376,47"/>
</map>
</div>

</div>
</div>
<a id="a600e551abcaab4c45b8e88e7ea3c219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600e551abcaab4c45b8e88e7ea3c219d">&#9670;&nbsp;</a></span>compute_slice_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> size_t atp::logic::equational::compute_slice_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for computing the number of elements in slices. </p>
<dl class="section pre"><dt>Precondition</dt><dd>start &lt;= end and step &gt; 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>returns the number of integers k &gt;= 0 such that start + k * step &lt; end. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph" id="namespaceatp_1_1logic_1_1equational_a600e551abcaab4c45b8e88e7ea3c219d_icgraph">
<area shape="rect" title="Helper function for computing the number of elements in slices." alt="" coords="475,119,620,161"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_statement_array.html#ada8f04815314efc4e444cce3d22db612" title=" " alt="" coords="273,89,427,130"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_statement_array.html#a88936889bc98a77d1f0ccc070e5728e6" title=" " alt="" coords="37,151,193,193"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#a4c122c0c52a6dc8b77975749d2710535" title="Characterises the information provided to this knowledge kernel in a single integer code." alt="" coords="37,5,193,61"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_statement_array.html#a427d3b1b8f56c9593fffc55ef3ce11e0" title=" " alt="" coords="5,86,225,127"/>
</map>
</div>

</div>
</div>
<a id="a28b43007ab2f1f5d4849d5b958f376fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b43007ab2f1f5d4849d5b958f376fb">&#9670;&nbsp;</a></span>fold_pair_syntax_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqPairFuncT , typename FreePairFuncT , typename ConstPairFuncT , typename FuncPairFuncT , typename DefaultPairFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::fold_pair_syntax_tree </td>
          <td>(</td>
          <td class="paramtype">EqPairFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreePairFuncT&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPairFuncT&#160;</td>
          <td class="paramname"><em>const_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncPairFuncT&#160;</td>
          <td class="paramname"><em>f_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DefaultPairFuncT&#160;</td>
          <td class="paramname"><em>default_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fold over pairs of syntax trees, where the fold constructor is dependent on the node types of the pair. There are functions for pairs of matching types, and then a default function for when the pairs do not match. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>The return type (all functions must return this type.)</td></tr>
    <tr><td class="paramname">EqPairFuncT</td><td>The function operating on pairs of equality nodes, must have signature <code>ResultT x ResultT -&gt; ResultT</code></td></tr>
    <tr><td class="paramname">FreePairFuncT</td><td>The function operating on pairs of free variable nodes, must have signature <code>size_t x size_t -&gt; ResultT</code> where the two given integers are the free variable IDs in the pair.</td></tr>
    <tr><td class="paramname">ConstPairFuncT</td><td>The function operating on pairs of constants, must have signature <code>size_t x size_t -&gt; ResultT</code> where the two integers are the symbol IDs of the constants</td></tr>
    <tr><td class="paramname">FuncPairFuncT</td><td>The function operating on pairs of function nodes, must have signature <code>size_t x size_t x std::vector&lt; ResultT&gt;::iterator x std::vector&lt;ResultT&gt;::iterator -&gt; ResultT</code> where the two integers are the symbol IDs of the functions and the two iterators are the begin and end iterators of the function arguments' results.</td></tr>
    <tr><td class="paramname">DefaultPairFuncT</td><td>This is called when a pair of nodes are encountered but don't have the same type, and it must have signature <code>SyntaxNodePtr x SyntaxNodePtr -&gt; ResultT</code>, where the two arguments are just the two nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5f7bc7ced86a79f9e8f436630704152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f7bc7ced86a79f9e8f436630704152">&#9670;&nbsp;</a></span>fold_parse_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqFuncT , typename IdentifierFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::fold_parse_tree </td>
          <td>(</td>
          <td class="paramtype">EqFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IdentifierFuncT&#160;</td>
          <td class="paramname"><em>identifier_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a>&#160;</td>
          <td class="paramname"><em>p_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fold operation over a given parse tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>The return type of this operation.</td></tr>
    <tr><td class="paramname">EqFuncT</td><td>The function to use as the equality node constructor, which must have type ResultT x ResultT -&gt; ResultT</td></tr>
    <tr><td class="paramname">IdentifierFuncT</td><td>The function to use as the identifier node constructor, which must have type std::string x std::vector&lt;ResultT&gt;::iterator x std::vector&lt;ResultT&gt;::iterator -&gt; ResultT</td></tr>
  </table>
  </dd>
</dl>
<p>Folds are a special kind of concept, prominent in functional programming. Applying a fold to a tree like this one can be a useful way of computing/aggregating information over the tree without having to write boilerplate code. A fold basically works by specifying a function to apply for each kind of node, and the fold then handles the rest of the recursion for you. However, recursion is inefficient, so we use a stack instead. In particular, we use two stacks: one for keeping track of which nodes we are yet to examine, and which results we are yet to use. Some nodes need to be examined twice (the first time, we push its children onto the stack. the second time, we combine the results of its children and push our result to the results_stack) thus we have a set of seen nodes too. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph" id="namespaceatp_1_1logic_1_1equational_ac5f7bc7ced86a79f9e8f436630704152_cgraph">
<area shape="rect" title="Perform a fold operation over a given parse tree." alt="" coords="5,266,148,307"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a6618f693f5e35cb6a1858b21e1a9b1a2" title=" " alt="" coords="212,5,355,61"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a3818c3237a7a55c740540293031e4678" title=" " alt="" coords="198,86,369,127"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a551c25e7739c0344a9fc78d76e8616df" title=" " alt="" coords="212,152,355,208"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_i_parse_node.html#ad1c5644349c91762784561e984c333bc" title=" " alt="" coords="206,233,361,274"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html#a315b06b092eff96a2f708ab8bfea4dd8" title=" " alt="" coords="212,298,355,339"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a4addc3dc6f1148c3da4d04a89b028dff" title=" " alt="" coords="212,364,355,420"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_identifier_parse_node.html#a7516bc05c496bf3aa2de7928826ae23c" title=" " alt="" coords="196,445,371,486"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_parse_node.html#a79b29db5e3721a74755ac89e53f97a5b" title=" " alt="" coords="212,510,355,551"/>
</map>
</div>

</div>
</div>
<a id="a91b11e0f5e91e0a6368650b5a93fa992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b11e0f5e91e0a6368650b5a93fa992">&#9670;&nbsp;</a></span>fold_syntax_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename EqFuncT , typename FreeFuncT , typename ConstFuncT , typename FFuncT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultT atp::logic::equational::fold_syntax_tree </td>
          <td>(</td>
          <td class="paramtype">EqFuncT&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFuncT&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstFuncT&#160;</td>
          <td class="paramname"><em>const_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFuncT&#160;</td>
          <td class="paramname"><em>f_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>p_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a fold operation over a given syntax tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultT</td><td>The return type of this operation.</td></tr>
    <tr><td class="paramname">EqFuncT</td><td>The function to use as the equality node constructor, which must have type ResultT x ResultT -&gt; ResultT</td></tr>
    <tr><td class="paramname">FreeFuncT</td><td>The function to use as the free variable node constructor, with type size_t -&gt; ResultT</td></tr>
    <tr><td class="paramname">ConstFuncT</td><td>The function to use as the constant node constructor, with type size_t -&gt; ResultT</td></tr>
    <tr><td class="paramname">FFuncT</td><td>The function to use as the function node constructor, with type size_t x std::vector&lt;ResultT&gt;::iterator x std::vector&lt;ResultT&gt;::iterator -&gt; ResultT</td></tr>
  </table>
  </dd>
</dl>
<p>Folds are a special kind of concept, prominent in functional programming. Applying a fold to a tree like this one can be a useful way of computing/aggregating information over the tree without having to write boilerplate code. A fold basically works by specifying a function to apply for each kind of node, and the fold then handles the rest of the recursion for you. However, recursion is inefficient, so we use a stack instead. In particular, we use two stacks: one for keeping track of which nodes we are yet to examine, and which results we are yet to use. Some nodes need to be examined twice (the first time, we push its children onto the stack. the second time, we combine the results of its children and push our result to the results_stack) thus we have a set of seen nodes too. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a91b11e0f5e91e0a6368650b5a93fa992_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a91b11e0f5e91e0a6368650b5a93fa992_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a91b11e0f5e91e0a6368650b5a93fa992_cgraph" id="namespaceatp_1_1logic_1_1equational_a91b11e0f5e91e0a6368650b5a93fa992_cgraph">
<area shape="rect" title="Perform a fold operation over a given syntax tree." alt="" coords="5,39,148,80"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html#a7b02313098b774b341ab0d1345e30bf3" title=" " alt="" coords="200,5,343,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html#a2f67d6c339fae955e0aad941e00f5378" title=" " alt="" coords="196,71,347,112"/>
</map>
</div>

</div>
</div>
<a id="a937ec99a9c46acc458fc08b706187350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937ec99a9c46acc458fc08b706187350">&#9670;&nbsp;</a></span>Identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::spirit::qi::rule&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#ae54101c14d30ddb9798a1f747adee92b">QiParseIterator</a>, std::string(), <a class="el" href="structatp_1_1logic_1_1equational_1_1_skipper.html">Skipper</a> &gt; atp::logic::equational::Identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse rule for identifiers. </p>
<p>An identifier is a kind of name, for a free variable, constant or function. Includes alphanumeric and some symbols. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph" id="namespaceatp_1_1logic_1_1equational_a937ec99a9c46acc458fc08b706187350_icgraph">
<area shape="rect" title="Parse rule for identifiers." alt="" coords="265,13,408,54"/>
<area shape="rect" href="structatp_1_1logic_1_1equational_1_1_statement_grammar.html#accc11d7d49fd2976f194ad146bfba551" title=" " alt="" coords="5,5,217,61"/>
</map>
</div>

</div>
</div>
<a id="a328cf188236eb9da94082159cb4ab37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328cf188236eb9da94082159cb4ab37b">&#9670;&nbsp;</a></span>parse_statements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> boost::optional&lt; std::list&lt; <a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a> &gt; &gt; atp::logic::equational::parse_statements </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a stream of line separated statements, and return the list of their parse trees, or None if an error occurred with any of them. </p>
<dl class="section note"><dt>Note</dt><dd>Comments are done using the hashtag # </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph" id="namespaceatp_1_1logic_1_1equational_a328cf188236eb9da94082159cb4ab37b_icgraph">
<area shape="rect" title="Read a stream of line separated statements, and return the list of their parse trees,..." alt="" coords="651,13,793,54"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#a69f343234c2d15259f98c635a70fd017" title="Load an array of statements from an input stream, in the given context." alt="" coords="407,13,603,54"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#addf8285cbe27bb9cf0002f07c97f4bd7" title="A builder function for this model context implementation." alt="" coords="205,5,359,61"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#ac5e49a1ba6f54c4616f3b8f3021d8c8b" title="Create a knowledge kernel corresponding to a given model context." alt="" coords="5,5,157,61"/>
</map>
</div>

</div>
</div>
<a id="a21fd07efe73f4ffca98e0a24d9d5d6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fd07efe73f4ffca98e0a24d9d5d6d5">&#9670;&nbsp;</a></span>ptree_to_stree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_t_p_logic_a_p_i_8h.html#a193fc37208eae7f616325dca675bae63">ATP_LOGIC_API</a> <a class="el" href="namespaceatp_1_1logic_1_1equational.html#a512c70cd56e63c05c448e31bbb98d6d9">SyntaxNodePtr</a> atp::logic::equational::ptree_to_stree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatp_1_1logic_1_1equational.html#aa4c176681e5964c28c42d71bfdb754ae">ParseNodePtr</a>&#160;</td>
          <td class="paramname"><em>ptree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatp_1_1logic_1_1equational_1_1_model_context.html">ModelContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a parse tree into a syntax tree. </p>
<dl class="section note"><dt>Note</dt><dd>This performs type checking, which is why we require the context</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if failed, otherwise returns the root to the syntax tree. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_cgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_cgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_cgraph" id="namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_cgraph">
<area shape="rect" title="Convert a parse tree into a syntax tree." alt="" coords="5,217,148,259"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html#adb58c20cd665a8b23c60edd5ed75429b" title="Optimised allocation function." alt="" coords="203,5,381,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_free_syntax_node.html#a6c72e391752c93140d133f17974580cd" title=" " alt="" coords="197,71,387,112"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_constant_syntax_node.html#aac3333f20bb2a2d8022507d83ad317e6" title="Optimised allocation function." alt="" coords="211,137,373,193"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_model_context.html#a4a13ee6033570021f12adc6dfb82485a" title=" " alt="" coords="204,217,380,259"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html#af53dda859eb584b8d4672af3dd1a6c37" title="Optimised allocation function which MOVES the child nodes in the [begin,end) range." alt="" coords="208,283,376,339"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_model_context.html#a82a047814726e2f1927f0db2209c10fc" title=" " alt="" coords="196,364,388,405"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_model_context.html#a675ab83d420a26747e22621cef7b542b" title=" " alt="" coords="203,429,381,471"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_eq_syntax_node.html#adf575b8fe9aecacfcfdcfa7ccc9e99eb" title=" " alt="" coords="449,5,661,47"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_free_syntax_node.html#ac7b032d740a79be5c3b1f4d5eff1ae8b" title=" " alt="" coords="439,71,671,112"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_constant_syntax_node.html#a1982739f90314f327800f8ab6fa378f9" title=" " alt="" coords="475,137,636,193"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html#af8bbe7076bf6e40c8a21bb7325f935be" title=" " alt="" coords="471,225,640,267"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html#adcfeb259ac22acee62636d3542f462a9" title=" " alt="" coords="476,291,635,332"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_func_syntax_node.html#a33ca218336849cb24abc954865d0e81e" title=" " alt="" coords="436,356,675,397"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_icgraph.png" border="0" usemap="#namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_icgraph" alt=""/></div>
<map name="namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_icgraph" id="namespaceatp_1_1logic_1_1equational_a21fd07efe73f4ffca98e0a24d9d5d6d5_icgraph">
<area shape="rect" title="Convert a parse tree into a syntax tree." alt="" coords="651,13,793,54"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#a69f343234c2d15259f98c635a70fd017" title="Load an array of statements from an input stream, in the given context." alt="" coords="407,13,603,54"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_knowledge_kernel.html#addf8285cbe27bb9cf0002f07c97f4bd7" title="A builder function for this model context implementation." alt="" coords="205,5,359,61"/>
<area shape="rect" href="classatp_1_1logic_1_1equational_1_1_language.html#ac5e49a1ba6f54c4616f3b8f3021d8c8b" title="Create a knowledge kernel corresponding to a given model context." alt="" coords="5,5,157,61"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
