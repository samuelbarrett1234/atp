# REWRITE RULES FOR LOGIC WITH EQUALITY
# three dots means bidirectional replacement rule: ...
# three arrows means unidirectional replacement rule: >>>
# any free variables/letters in the expressions are free to be chosen
# by the algorithm (they technically have a type, but I haven't written
# the type in formally. You should be able to guess the type by looking
# at the syntax, i.e. P(x) is a predicate, R(x, y, z, ...) is an n-ary
# relation, etc) but these should technically be written in.
# note that "<something> ... true" basically means that "<something>" is an axiom.

# PROPOSITIONAL RULES

\not true ... false
\not \not P ... P
true \and true ... true
true \and false ... false
false \and false ... false
A \and B ... B \and A
true \or true ... true
true \or false ... true
false \or false ... false
A \or B ... B \or A
A \and B >>> A \or B
A \and B >>> A
A >>> A \or B
A \and A >>> A  # duplicate As
A \or A >>> A # duplicate As

# FIRST ORDER RULES

\forall x . P(x) ... \exists x . P(x)
\forall x . \forall y . P(x, y) ... \forall y . \forall x . P(x, y)
\exists x . \exists y . P(x, y) ... \exists y . \exists x . P(x, y)
\forall x . P(x) ... \not \exists x . \not P(x)
\forall x . true ... true
\exists x . true ... true

# SET MEMBERSHIP RULES

# here are the rules for universe elements, but we need
# analogous rules for tuple elements.
x \in \emptyset ... false
x \in {x} ... true
x \in {y|P(y)} ... P(x)
\forall x . \exists_set S . S == {x} ... true
\exists_set S . S == { y | P(y) } ... true

# SET EQUALITY RULES

x = y >>> x \in S <-> y \in S  # one way because the set S won't be universally quantified
x = y >>> P(x) <-> P(y)  # likewise here
x = y >>> f(x) = f(y)  # and here

#  need to be very careful about the backwards directions here
# because they introduce new variables. These variables are free
# in these expressions, but it is up to the algorithm to link it
# with an existing variable when the rule is used

x = x ... true
x = y \and y = z ... x = z
x /= y ... \not x = y

# example usage:
# true ... \forall x . true ... \forall x . x = x
# note how it only applied the rule to an existing variable

# SECOND ORDER RULES

\forall_sets S . P(S) ... \exists_set S . P(S)
\forall_sets S . \forall_sets T . P(S, T) ... \forall_sets T . \forall_sets S . P(S, T)
\exists_set S . \exists_set T . P(S, T) ... \exists_set T . \exists_set S . P(S, T)
\forall_sets S . P(S) ... \not \exists_set S . \not P(S)
\forall_sets S . true ... true
\exists_set S . true ... true

# SECOND ORDER FIRST ORDER INTERACTION

\forall_sets S . \forall x . P(S, x) ... \forall x . \forall S . P(S, x)
\exists_set S . \exists x . P(S, x) ... \exists x . \exists_set S . P(S, x)

# TUPLES AND RELATIONS (should be sufficient to construct functions)
# (we will definitely need some help from the interpreter to parse these!)
# IMPORTANT REMARK: arity of tuples is fixed at compile time!

R(x1,..,xn) ... (x1,..,xn) \in R
(x1,..,xn) = (y1,..,yn) ... x1=y1 \and .. \and xn=yn
(x1,..,xn) /= (y1,..,ym) whenever m /= n  # (this is implemented by the compiler, not in the logic)

# SET ALGEBRA RULES

x \in (A \cup B) ... x \in A \or x \in B
x \in (A \cap B) ... x \in A \and x \in B
x \in (A \diff B) ... x \in A \and \not x \in B
x \in (\complement A) ... \not x \in A
S \subset T ... \forall x . x \in S -> x \in T
S \superset T ... T \subset S
S == T ... S \subset T \and T \subset S
S =/= T ... \not S == T

\forall_sets S T . \exists_set A . A = S \cup T ... true
\forall_sets S T . \exists_set A . A = S \cap T ... true
\forall_sets S T . \exists_set A . A = S \diff T ... true
\forall_sets S . \exists_set A . A = \complement S ... true

# NOETHERIAN INDUCTION

# a relation is well-founded if it has "no infinite decending chains"
\well_founded R ... \forall_sets S . S =/= \emptyset -> (\exists m . (m \in S \and \forall s . (s \in S -> \not R(s, m))))

\inductive_step R P ... (\forall x . (\forall y . R(y, x) -> P(y)) -> P(x))

\well-founded R \and \inductive_step R P ... \forall x . P(x)  # induction!

# NATURAL NUMBERS
# (\nat is a set, \succ x is a function, \lt(x, y) is a binary relation)
# (I suppose those three objects are implicitly existentially quantified!)

\exists_set S . S = \nat ... true  # classifying \nat as a set
x \in \nat -> \succ x \in \nat ... true
x /= \succ x ... true
\lt(x, \succ x) ... true
\lt(x, x) ... false
\lteq(x, y) ... x = y \or \lt(x, y)
\forall_sets S . S \subset \nat -> \exists x . x \in S \and \forall y . y \in S -> \lteq(x, y) ... true  # well-ordering property of the natural numbers
(\forall z \in \nat_zero . P(z)) \and (\forall n . n \in \nat -> (P(n) -> P(\succ n))) ... \forall n . n \in \nat -> P(n)  # probably redundant induction (we already have Noetherian induction and also the WOP implies induction anyway.)

x \in \nat_zero ... x \in \nat \and (\forall y . y \in \nat -> \lteq(x, y)) ... true  # this set is nonempty by the well-ordering property
x \in \nat_zero \and y \in \nat_zero >>> x = y  # \nat has a unique smallest element (so \nat_zero is a set of size exactly 1)

# FUNCTIONS

# recall that functions are binary relations s.t. f(x)=y iff f(x, y) is true

\isfunction f ... \forall x . \forall y . \forall z . f(x, y) \and f(x, z) -> y = z
\domain f ... { x | \exists y . f(x, y) }
\image f ... { x | \exists y . f(y, x) }
